class_name BoardManager extends Node2D

# Settings
@export var width: int = 7
@export var height: int = 8
@export var tile_size: int = 60
@export var piece_scene: PackedScene
@export var floating_text_scene: PackedScene
@export var vfx_explosion_scene: PackedScene

# BALANCE CONSTANTS
const MANA_PER_GEM: int = 5  # Base mana gained per gem matched (adjustable for balance)

var piece_types: Array[String] = ["red", "blue", "green", "yellow", "purple"]

# PRELOAD TEXTURES (NEW PATHS)
var gem_textures = {
	"red": preload("res://01_Assets/Art/Gems/gem_red.png"),
	"blue": preload("res://01_Assets/Art/Gems/gem_blue.png"),
	"green": preload("res://01_Assets/Art/Gems/gem_green.png"),
	"yellow": preload("res://01_Assets/Art/Gems/gem_yellow.png"),
	"purple": preload("res://01_Assets/Art/Gems/gem_purple.png")
}

signal turn_finished 
signal damage_dealt(total_damage: int, damage_type: String, match_count: int, combo_count: int)
signal mana_gained(amount: int, color_type: String)

var current_combo: int = 0

# Setter for managing input and hint timer combined
var is_processing_move: bool = false:
	set(value):
		is_processing_move = value
		if not is_processing_move:
			_start_hint_timer()
		else:
			_stop_hint_timer()

var start_pos: Vector2
var all_pieces: Array = [] 

# Hint System
var hint_timer: Timer
var active_hint_pieces: Array[GamePiece] = []
var active_hint_tweens: Array[Tween] = []

# Special Gem Chain Reaction Prevention
# Track activated grid positions instead of piece references (pieces get freed, positions don't)
var _activated_positions: Array[Vector2i] = []

func _ready() -> void:
	if not piece_scene:
		push_error("WARNING: 'piece_scene' not assigned to BoardManager!")
		return
		
	# TEXTURE DEBUG CHECK
	for type in gem_textures:
		var tex = gem_textures[type]
		if not tex:
			printerr("MISSING TEXTURE for: " + type)
		
	var total_w = width * tile_size
	var total_h = height * tile_size
	start_pos = Vector2(
		(720 - total_w) / 2 + (tile_size / 2), 
		340 + (tile_size / 2)
	)
	
	# Hint Timer Setup
	hint_timer = Timer.new()
	hint_timer.name = "HintTimer"
	hint_timer.wait_time = 5.0
	hint_timer.one_shot = true
	hint_timer.timeout.connect(_on_hint_timer_timeout)
	add_child(hint_timer)
	
	# Initial array setup (Don't spawn here if MainGame handles loading)
	all_pieces = []
	for x in range(width):
		all_pieces.append([])
		for y in range(height):
			all_pieces[x].append(null)

func spawn_board() -> void:
	_clear_board_visuals()
	
	for x in range(width):
		for y in range(height):
			var piece = piece_scene.instantiate() as GamePiece
			add_child(piece)
			
			piece.grid_position = Vector2i(x, y)
			all_pieces[x][y] = piece
			piece.swipe_detected.connect(_on_piece_swipe_detected)
			
			# No-Match Spawn Logic
			var possible_types = piece_types.duplicate()
			
			if x > 1:
				if all_pieces[x-1][y].type == all_pieces[x-2][y].type:
					possible_types.erase(all_pieces[x-1][y].type)
			if y > 1:
				if all_pieces[x][y-1].type == all_pieces[x][y-2].type:
					possible_types.erase(all_pieces[x][y-1].type)
			
			if possible_types.is_empty():
				piece.type = piece_types.pick_random() 
			else:
				piece.type = possible_types.pick_random()
			
			_update_piece_visual(piece)
			
			var target_pos = grid_to_pixel(x, y)
			piece.position = Vector2(target_pos.x, target_pos.y - 1000)
			var delay = y * 0.05 + x * 0.05
			var tween = create_tween()
			tween.tween_interval(delay)
			tween.tween_property(piece, "position", target_pos, 0.5).set_trans(Tween.TRANS_BOUNCE).set_ease(Tween.EASE_OUT)

	_start_hint_timer()

func _clear_board_visuals() -> void:
	# Clear existing children that are GamePieces
	for child in get_children():
		if child is GamePiece:
			child.queue_free()
	
	all_pieces = []
	for x in range(width):
		all_pieces.append([])
		for y in range(height):
			all_pieces[x].append(null)

# --- SERIALIZATION ---

func get_board_data() -> Array:
	var data = []
	for x in range(width):
		var col_data = []
		for y in range(height):
			if all_pieces[x][y] != null:
				col_data.append(all_pieces[x][y].type)
			else:
				col_data.append("") # Empty slot
		data.append(col_data)
	return data

func load_board_data(data: Array) -> void:
	_clear_board_visuals()
	
	for x in range(width):
		if x >= data.size(): break
		for y in range(height):
			if y >= data[x].size(): break
			
			var type = data[x][y]
			if type != "":
				var piece = piece_scene.instantiate() as GamePiece
				add_child(piece)
				piece.grid_position = Vector2i(x, y)
				all_pieces[x][y] = piece
				piece.swipe_detected.connect(_on_piece_swipe_detected)
				piece.type = type
				_update_piece_visual(piece)
				piece.position = grid_to_pixel(x, y)
	
	_start_hint_timer()

# --- CORE LOGIC ---

func _update_piece_visual(piece: GamePiece) -> void:
	# Correct node name strictly confirmed: Sprite
	var sprite = piece.get_node_or_null("Sprite")
	
	if not sprite:
		printerr("ERROR: GamePiece missing 'Sprite' node! Piece Type: ", piece.type)
		return

	if gem_textures.has(piece.type):
		var tex = gem_textures[piece.type]
		if tex:
			sprite.texture = tex
			sprite.modulate = Color.WHITE # Reset unexpected modulation
		else:
			# FALLBACK: Missing texture resource (but key exists)
			printerr("TEXTURE NULL: ", piece.type, " Using Color Fallback.")
			sprite.texture = preload("res://icon.svg")
			sprite.modulate = _get_debug_color(piece.type)
	else:
		# FALLBACK: Unknown type
		printerr("UNKNOWN TYPE: ", piece.type)
		sprite.texture = preload("res://icon.svg")
		sprite.modulate = Color.WHITE
		
	# DYNAMIC SCALING
	if sprite.texture:
		var tex_size = sprite.texture.get_size()
		var target_size = tile_size * 0.8
		var scale_factor = target_size / max(tex_size.x, tex_size.y)
		sprite.scale = Vector2(scale_factor, scale_factor)
	else:
		sprite.scale = Vector2(0.40, 0.40)
		
	# SPECIAL VISUALS - Delegate to helper class (Phase 3 refactor)
	SpecialGems.apply_special_visuals(piece)

func _get_debug_color(type: String) -> Color:
	match type:
		"red": return Color.RED
		"blue": return Color.BLUE
		"green": return Color.GREEN
		"yellow": return Color.YELLOW
		"purple": return Color.MAGENTA
	return Color.WHITE

func grid_to_pixel(x: int, y: int) -> Vector2:
	return Vector2(
		start_pos.x + (x * tile_size),
		start_pos.y + (y * tile_size)
	)
	
func _on_piece_swipe_detected(source_piece: GamePiece, direction: Vector2i) -> void:
	_clear_hints()

	if is_processing_move:
		return

	var start_coords = source_piece.grid_position
	var target_coords = start_coords + direction
	
	if target_coords.x < 0 or target_coords.x >= width or target_coords.y < 0 or target_coords.y >= height:
		return
		
	var target_piece = all_pieces[target_coords.x][target_coords.y]
	
	if target_piece:
		swap_pieces(source_piece, target_piece)
	
func swap_pieces(piece_1: GamePiece, piece_2: GamePiece) -> void:
	is_processing_move = true
	Audio.play_sfx("swap")
	
	current_combo = 0
	
	var pos_1 = piece_1.grid_position
	var pos_2 = piece_2.grid_position
	
	# Swap Data
	all_pieces[pos_1.x][pos_1.y] = piece_2
	all_pieces[pos_2.x][pos_2.y] = piece_1
	
	piece_1.grid_position = pos_2
	piece_2.grid_position = pos_1
	
	# Visual Swap
	var tween = create_tween().set_parallel(true).set_trans(Tween.TRANS_CUBIC)
	piece_1.z_index = 10
	piece_2.z_index = 10
	tween.tween_property(piece_1, "position", grid_to_pixel(pos_2.x, pos_2.y), 0.3)
	tween.tween_property(piece_2, "position", grid_to_pixel(pos_1.x, pos_1.y), 0.3)
	await tween.finished
	
	if not is_instance_valid(piece_1) or not is_instance_valid(piece_2):
		is_processing_move = false
		return
	
	piece_1.z_index = 0
	piece_2.z_index = 0
	
	# SPECIAL INTERACTION: Check for Special + Special combos
	var combo_handled = await _handle_special_combo(piece_1, piece_2)
	if combo_handled:
		return # Combo was executed, stop further processing
	
	# Check Matches (Standard)
	if find_matches():
		print("Match Found!")
		destroy_matched_pieces() 
	else:
		# BUG FIX #7 & #8: Revert swap visually and reset is_processing_move
		print("NO Match! Reverting...")
		Audio.play_sfx("error")
		
		# Visually swap back
		var revert_tween = create_tween().set_parallel(true).set_trans(Tween.TRANS_CUBIC)
		revert_tween.tween_property(piece_1, "position", grid_to_pixel(pos_1.x, pos_1.y), 0.3)
		revert_tween.tween_property(piece_2, "position", grid_to_pixel(pos_2.x, pos_2.y), 0.3)
		await revert_tween.finished
		
		# Revert data
		all_pieces[pos_1.x][pos_1.y] = piece_1
		all_pieces[pos_2.x][pos_2.y] = piece_2
		piece_1.grid_position = pos_1
		piece_2.grid_position = pos_2
		
		# Reset z-index
		piece_1.z_index = 0
		piece_2.z_index = 0
		
		# BUG FIX #8: Reset is_processing_move
		is_processing_move = false

func get_match_cluster(start_x: int, start_y: int, visited_mask: Array) -> Array[GamePiece]:
	# Delegate to static helper (Phase 3 refactor)
	return MatchDetector.get_match_cluster(start_x, start_y, all_pieces, visited_mask, width, height)

func _detect_cluster_shape(cluster: Array[GamePiece]) -> String:
	# Analyzes cluster shape and returns: "horizontal", "vertical", "t_shape", "l_shape", or "irregular"
	if cluster.size() < 4:
		return "irregular"
	
	var xs: Array[int] = []
	var ys: Array[int] = []
	
	for p in cluster:
		if is_instance_valid(p):
			xs.append(p.grid_position.x)
			ys.append(p.grid_position.y)
	
	if xs.is_empty() or ys.is_empty():
		return "irregular"
	
	var unique_xs = []
	var unique_ys = []
	for x in xs:
		if x not in unique_xs:
			unique_xs.append(x)
	for y in ys:
		if y not in unique_ys:
			unique_ys.append(y)
	
	var x_span = unique_xs.size()
	var y_span = unique_ys.size()
	
	# Pure horizontal line: all same Y
	if y_span == 1:
		return "horizontal"
	
	# Pure vertical line: all same X
	if x_span == 1:
		return "vertical"
	
	# T-shape or L-shape: spans both X and Y
	# T-shape: One axis has 3+ unique values, other has 2
	# L-shape: Both axes have 2 unique values (corner pattern)
	
	if x_span == 2 and y_span == 2:
		# Could be L-shape (corner)
		return "l_shape"
	elif (x_span >= 3 and y_span == 2) or (x_span == 2 and y_span >= 3):
		# T-shape pattern
		return "t_shape"
	elif x_span >= 3 or y_span >= 3:
		# Extended T or cross pattern
		return "t_shape"
	
	return "irregular"

func _create_special_gem_at(x: int, y: int, s_type: GamePiece.SpecialType, color_type: String) -> void:
	var piece = all_pieces[x][y]
	if not piece: return
	
	Audio.play_sfx("upgrade")
	Audio.vibrate_heavy()  # HAPTIC: Strong feedback for special gem creation
	piece.special_type = s_type
	piece.matched = false # Reset matched status so it survives
	
	# Visual Update
	_update_piece_visual(piece)
	spawn_floating_text("SPECIAL!", 0, "yellow", piece.global_position)
	
	# Juice
	var t = create_tween()
	t.tween_property(piece, "scale", Vector2(1.5, 1.5), 0.2).set_trans(Tween.TRANS_BACK)
	t.tween_property(piece, "scale", Vector2.ONE, 0.2)

func activate_special_gem(piece: GamePiece) -> void:
	# Validate piece is still valid (not freed/queued for deletion)
	if not is_instance_valid(piece):
		return

	if piece.special_type == GamePiece.SpecialType.NONE:
		return

	# CRITICAL: Store position data BEFORE any operations that might free the piece
	var piece_position = piece.global_position
	var piece_grid_pos = piece.grid_position

	# Prevent infinite recursion - check if this position is already being activated
	if piece_grid_pos in _activated_positions:
		print("!!! RECURSION PREVENTED: Position ", piece_grid_pos, " already activating")
		return

	# Add position to tracking array
	_activated_positions.append(piece_grid_pos)

	# Store type before disabling
	var special_type_backup = piece.special_type

	print("!!! ACTIVATING SPECIAL GEM: ", special_type_backup, " at ", piece_grid_pos)
	Audio.play_sfx("explosion")

	# Disable special before chain reactions to prevent re-activation
	piece.special_type = GamePiece.SpecialType.NONE

	match special_type_backup:
		GamePiece.SpecialType.ROW_BLAST:
			# Clear Row
			for i in range(width):
				var target = all_pieces[i][piece_grid_pos.y]
				if is_instance_valid(target) and target != piece:
					# Chain Reaction
					if target.special_type != GamePiece.SpecialType.NONE:
						activate_special_gem(target)

					damage_piece(target)
					all_pieces[i][piece_grid_pos.y] = null
			spawn_floating_text("ROW BLAST!", 0, "red", piece_position)

		GamePiece.SpecialType.COL_BLAST:
			# Clear Column
			for j in range(height):
				var target = all_pieces[piece_grid_pos.x][j]
				if is_instance_valid(target) and target != piece:
					if target.special_type != GamePiece.SpecialType.NONE:
						activate_special_gem(target)

					damage_piece(target)
					all_pieces[piece_grid_pos.x][j] = null
			spawn_floating_text("COL BLAST!", 0, "blue", piece_position)

		GamePiece.SpecialType.AREA_BOMB:
			# Clear 3x3 area around the piece
			var cx = piece_grid_pos.x
			var cy = piece_grid_pos.y
			for dx in range(-1, 2):
				for dy in range(-1, 2):
					var tx = cx + dx
					var ty = cy + dy
					if tx >= 0 and tx < width and ty >= 0 and ty < height:
						var target = all_pieces[tx][ty]
						if is_instance_valid(target) and target != piece:
							if target.special_type != GamePiece.SpecialType.NONE:
								activate_special_gem(target)
							damage_piece(target)
							all_pieces[tx][ty] = null
			spawn_floating_text("BOMB!", 0, "yellow", piece_position)

		GamePiece.SpecialType.RAINBOW:
			# Store type before async operation (piece might be freed during await)
			var piece_type = piece.type if is_instance_valid(piece) else "red"
			# Destroy all of one color (use safe version to prevent recursion)
			await _destroy_gems_by_color_safe(piece_type)
			spawn_floating_text("RAINBOW!", 0, "purple", piece_position)

	# Remove position from tracking array
	_activated_positions.erase(piece_grid_pos)

func destroy_matched_pieces() -> void:
	var was_match_found = false
	var visited_mask = []
	for i in range(width):
		var col = []
		col.resize(height)
		col.fill(false)
		visited_mask.append(col)
		
	# Find independent clusters
	for x in range(width):
		for y in range(height):
			var current_piece = all_pieces[x][y]
			if current_piece != null and is_instance_valid(current_piece) and current_piece.matched and not visited_mask[x][y]:
				# Found a new cluster
				was_match_found = true

				# CRITICAL: Increment combo per cluster found
				current_combo += 1

				var cluster = get_match_cluster(x, y, visited_mask)

				# Process this specific cluster
				if not cluster.is_empty():
					# Validate first piece before accessing
					if not is_instance_valid(cluster[0]):
						continue
					var type = cluster[0].type
					var list_size = cluster.size()
					var damage_amount = list_size * 10
					
					# Emit EXACTLY for this cluster with the current sequential combo ID
					damage_dealt.emit(damage_amount, type, list_size, current_combo)
					mana_gained.emit(list_size * MANA_PER_GEM, type)
					
					# SPECIAL GEM CREATION LOGIC
					var special_created = false
					var spawn_pos = cluster[0].grid_position if is_instance_valid(cluster[0]) else Vector2i(0, 0)
					var created_piece = null

					if list_size >= 4:
						# Pick optimal position (center or cluster[1])
						if list_size > 1 and is_instance_valid(cluster[1]):
							spawn_pos = cluster[1].grid_position
						elif is_instance_valid(cluster[0]):
							spawn_pos = cluster[0].grid_position
						
						var new_special_type = GamePiece.SpecialType.ROW_BLAST 
						
						if list_size >= 5:
							# 5+ in a line = Rainbow
							new_special_type = GamePiece.SpecialType.RAINBOW
						elif list_size == 4:
							# Detect shape: Line (Row/Col) vs T/L (Area Bomb)
							var shape = _detect_cluster_shape(cluster)
							match shape:
								"horizontal":
									new_special_type = GamePiece.SpecialType.ROW_BLAST
								"vertical":
									new_special_type = GamePiece.SpecialType.COL_BLAST
								"t_shape", "l_shape":
									new_special_type = GamePiece.SpecialType.AREA_BOMB
									spawn_floating_text("T/L MATCH!", 0, "yellow", cluster[0].global_position)
								_:
									# Irregular 4-match, default to row blast
									new_special_type = GamePiece.SpecialType.ROW_BLAST
							
						# Evolution
						_create_special_gem_at(spawn_pos.x, spawn_pos.y, new_special_type, type)
						created_piece = all_pieces[spawn_pos.x][spawn_pos.y]
						special_created = true

					# Destroy pieces (and Activate specials)
					for piece in cluster:
						# Validate piece before accessing
						if not is_instance_valid(piece):
							continue

						# If this is the piece we just created/evolved, SKIP destruction
						if special_created and piece == created_piece:
							continue

						# If piece was ALREADY special, activate it
						if piece.special_type != GamePiece.SpecialType.NONE:
							activate_special_gem(piece)

						# Store grid pos before damaging (piece might get freed)
						var grid_x = piece.grid_position.x
						var grid_y = piece.grid_position.y
						damage_piece(piece)
						all_pieces[grid_x][grid_y] = null
	
	# CRITICAL FIX: Call refill_board after destroying pieces
	if was_match_found:
		await get_tree().create_timer(0.3).timeout  # Wait for destruction animation
		refill_board()


func damage_piece(piece: GamePiece) -> void:
	if not is_instance_valid(piece):
		return

	if vfx_explosion_scene:
		var vfx = vfx_explosion_scene.instantiate() as VFX_Explosion
		add_child(vfx)
		vfx.z_index = 20
		# Try to get color from texture if possible, or just default to white/piece type color
		var sprite = piece.get_node_or_null("Sprite")
		vfx.setup(piece.position, sprite.modulate if sprite else Color.WHITE)

	var tween = create_tween()
	tween.tween_property(piece, "scale", Vector2.ZERO, 0.2)
	tween.finished.connect(piece.queue_free)
	
func find_matches() -> bool:
	# Delegate to static helper (Phase 3 refactor)
	return MatchDetector.find_matches(all_pieces, width, height)

func refill_board() -> void:
	var tween = create_tween().set_parallel(true).set_trans(Tween.TRANS_BOUNCE).set_ease(Tween.EASE_OUT)
	
	for x in range(width):
		for y in range(height - 1, -1, -1):
			if all_pieces[x][y] == null:
				for k in range(y - 1, -1, -1):
					if all_pieces[x][k] != null and is_instance_valid(all_pieces[x][k]):
						move_piece(x, k, x, y, tween)
						break
				
				if all_pieces[x][y] == null:
					spawn_new_piece(x, y, tween)
					
	await tween.finished
	
	if find_matches():
		destroy_matched_pieces()
	else:
		_check_for_deadlock_and_finish()

func _check_for_deadlock_and_finish() -> void:
	var possible_move = find_possible_move()
	if not possible_move.is_empty():
		is_processing_move = false
		turn_finished.emit()
	else:
		print("DEADLOCK DETECTED! Shuffling...")
		await shuffle_board()

		# Recursive check after shuffle
		if find_matches():
			destroy_matched_pieces()
		else:
			_check_for_deadlock_and_finish()

func move_piece(from_x: int, from_y: int, to_x: int, to_y: int, tween: Tween) -> void:
	var piece = all_pieces[from_x][from_y]
	if not is_instance_valid(piece):
		return
	all_pieces[to_x][to_y] = piece
	all_pieces[from_x][from_y] = null
	piece.grid_position = Vector2i(to_x, to_y)
	tween.tween_property(piece, "position", grid_to_pixel(to_x, to_y), 0.4)

func spawn_new_piece(x: int, y: int, tween: Tween) -> void:
	var piece = piece_scene.instantiate() as GamePiece
	add_child(piece)
	piece.grid_position = Vector2i(x, y)
	all_pieces[x][y] = piece
	piece.swipe_detected.connect(_on_piece_swipe_detected)
	piece.type = piece_types.pick_random()
	_update_piece_visual(piece)
	
	var target_pos = grid_to_pixel(x, y)
	piece.position = Vector2(target_pos.x, target_pos.y - 600) 
	tween.tween_property(piece, "position", target_pos, 0.4)

# --- FEATURE: DEADLOCK SHUFFLE ---

func shuffle_board() -> void:
	spawn_floating_text("SHUFFLING!", 0, "red", get_viewport_rect().get_center())
	Audio.play_sfx("combo")
	
	var pieces: Array[GamePiece] = []
	for x in range(width):
		for y in range(height):
			if all_pieces[x][y]:
				pieces.append(all_pieces[x][y])
	
	for p in pieces:
		p.type = piece_types.pick_random()
		_update_piece_visual(p)
		var t = create_tween()
		t.tween_property(p, "scale", Vector2(1.2, 1.2), 0.1)
		t.tween_property(p, "scale", Vector2.ONE, 0.1)
		
	await get_tree().create_timer(0.3).timeout

# --- FEATURE: HINT SYSTEM ---

func find_possible_move() -> Array[GamePiece]:
	for x in range(width):
		for y in range(height):
			var current = all_pieces[x][y]
			if not current: continue
			
			if x < width - 1:
				var neighbor = all_pieces[x+1][y]
				if _simulate_swap(current, neighbor, x, y, x+1, y):
					return [current, neighbor]
			
			if y < height - 1:
				var neighbor = all_pieces[x][y+1]
				if _simulate_swap(current, neighbor, x, y, x, y+1):
					return [current, neighbor]
	return []

func _simulate_swap(p1: GamePiece, p2: GamePiece, x1: int, y1: int, x2: int, y2: int) -> bool:
	if not p1 or not p2: return false
	
	all_pieces[x1][y1] = p2
	all_pieces[x2][y2] = p1
	
	var has_match = _check_match_at(x1, y1) or _check_match_at(x2, y2)
	
	all_pieces[x1][y1] = p1
	all_pieces[x2][y2] = p2
	
	return has_match

func _check_match_at(x: int, y: int) -> bool:
	var current = all_pieces[x][y]
	if not current: return false
	var t = current.type
	
	# Check horizontal matches (with null guards)
	if x > 0 and x < width - 1:
		var left = all_pieces[x-1][y]
		var right = all_pieces[x+1][y]
		if left and right and left.type == t and right.type == t: return true
	if x < width - 2:
		var right1 = all_pieces[x+1][y]
		var right2 = all_pieces[x+2][y]
		if right1 and right2 and right1.type == t and right2.type == t: return true
	if x > 1:
		var left1 = all_pieces[x-1][y]
		var left2 = all_pieces[x-2][y]
		if left1 and left2 and left1.type == t and left2.type == t: return true
		
	# Check vertical matches (with null guards)
	if y > 0 and y < height - 1:
		var up = all_pieces[x][y-1]
		var down = all_pieces[x][y+1]
		if up and down and up.type == t and down.type == t: return true
	if y < height - 2:
		var down1 = all_pieces[x][y+1]
		var down2 = all_pieces[x][y+2]
		if down1 and down2 and down1.type == t and down2.type == t: return true
	if y > 1:
		var up1 = all_pieces[x][y-1]
		var up2 = all_pieces[x][y-2]
		if up1 and up2 and up1.type == t and up2.type == t: return true
		
	return false

func _start_hint_timer() -> void:
	if hint_timer.is_stopped():
		hint_timer.start()

func _stop_hint_timer() -> void:
	hint_timer.stop()
	_clear_hints()

func _on_hint_timer_timeout() -> void:
	if is_processing_move: return
	
	var moves = find_possible_move()
	if not moves.is_empty():
		_animate_hint(moves)

func _animate_hint(pieces: Array[GamePiece]) -> void:
	_clear_hints()
	
	for p in pieces:
		if is_instance_valid(p):
			active_hint_pieces.append(p)
			var t = create_tween().set_loops()
			active_hint_tweens.append(t)
			t.tween_property(p, "scale", Vector2(1.15, 1.15), 0.6).set_trans(Tween.TRANS_SINE)
			t.tween_property(p, "scale", Vector2(1.0, 1.0), 0.6).set_trans(Tween.TRANS_SINE)
			p.modulate = Color.MAGENTA

func _clear_hints() -> void:
	for t in active_hint_tweens:
		if t and t.is_valid():
			t.kill()
	active_hint_tweens.clear()
	
	for p in active_hint_pieces:
		if is_instance_valid(p):
			p.modulate = Color.WHITE
			p.scale = Vector2.ONE
	active_hint_pieces.clear()

func spawn_floating_text(text: String, val: int, color_name: String, pos: Vector2) -> void:
	if not floating_text_scene: return
	var ft = floating_text_scene.instantiate()
	add_child(ft)
	ft.global_position = pos
	
	var c = Color.WHITE
	match color_name:
		"red": c = Color("#ff4d4d")
		"blue": c = Color("#4da6ff")
		"green": c = Color("#5cd65c")
		"yellow": c = Color("#ffd11a")
		"purple": c = Color("#ac00e6")
		_: c = Color.WHITE
		
	if ft.has_method("start_animation"):
		ft.start_animation(text, c)

# --- SKILL EFFECTS (Called by MainGame) ---

func destroy_all_of_color(target_color: String) -> void:
	Audio.play_sfx("combo")

	var targets: Array[GamePiece] = []
	for x in range(width):
		for y in range(height):
			var p = all_pieces[x][y]
			if p and is_instance_valid(p) and p.type == target_color:
				targets.append(p)

	if targets.is_empty():
		return

	# Visual
	spawn_floating_text("WIPE!", targets.size(), target_color, get_viewport_rect().get_center())

	current_combo += 1
	var total_dmg = targets.size() * 15

	damage_dealt.emit(total_dmg, target_color, targets.size(), current_combo)
	mana_gained.emit(targets.size() * 5, target_color)

	for p in targets:
		if is_instance_valid(p):
			var grid_x = p.grid_position.x
			var grid_y = p.grid_position.y
			damage_piece(p)
			all_pieces[grid_x][grid_y] = null
		
	await get_tree().create_timer(0.3).timeout
	refill_board()

func transmute_pieces(count: int, target_color: String) -> void:
	print("--- Transmute Triggered for: ", target_color, " ---")
	
	# MAPPING DICTIONARY (Element -> Board Color)
	var element_to_color = {
		"light": "yellow",
		"dark": "purple",
		"nature": "green",
		"fire": "red",
		"water": "blue",
		# Add direct mappings for safety if "red" is passed directly
		"red": "red",
		"blue": "blue",
		"green": "green",
		"yellow": "yellow",
		"purple": "purple"
	}
	
	# Normalization and Translation
	var raw_lower = target_color.to_lower()
	var final_color = raw_lower
	
	if element_to_color.has(raw_lower):
		final_color = element_to_color[raw_lower]
		print("Mapped element '", raw_lower, "' to color '", final_color, "'")
	else:
		print("WARNING: Element '", raw_lower, "' has no color mapping! Using raw value.")
	
	var candidates: Array[GamePiece] = []

	for x in range(width):
		for y in range(height):
			var p = all_pieces[x][y]
			# Ensure we don't transmute pieces that are already that color
			if p and is_instance_valid(p) and p.type != final_color:
				candidates.append(p)

	candidates.shuffle()
	var targets = candidates.slice(0, count)

	if targets.is_empty():
		print("No valid candidates for transmutation.")
		return

	Audio.play_sfx("match")
	spawn_floating_text("ALCHEMY!", targets.size(), final_color, get_viewport_rect().get_center())

	# 1. Apply changes visually and logically (Restored Loop)
	for p in targets:
		if not is_instance_valid(p):
			continue

		p.type = final_color

		# VFX with visual update
		var t = create_tween()
		t.tween_property(p, "scale", Vector2(0.1, 1.2), 0.1)

		# Explicitly update visual in callback
		t.tween_callback(func():
			if is_instance_valid(p):
				_update_piece_visual(p)
		)
		
		t.tween_property(p, "scale", Vector2.ONE, 0.1)
		
	# 2. WAIT for VFX to finish
	await get_tree().create_timer(0.3).timeout
	
	# 3. TRIGGER MATCHES
	if find_matches():
		print("Transmute caused matches! Destroying...")
		destroy_matched_pieces()
	else:
		_check_for_deadlock_and_finish()

func destroy_gems_by_color(color: String) -> void:
	# Iterate through all squares
	for x in range(width):
		for y in range(height):
			var current_piece = all_pieces[x][y]
			if current_piece and is_instance_valid(current_piece) and current_piece.type == color:
				damage_piece(current_piece)
				all_pieces[x][y] = null

	# Refill Board after clearing
	await get_tree().create_timer(0.3).timeout
	await refill_board()

# Safe version: Disables special gems before destroying to prevent chain reactions
func _destroy_gems_by_color_safe(color: String) -> void:
	# First pass: Disable all special gems of target color
	for x in range(width):
		for y in range(height):
			var current_piece = all_pieces[x][y]
			if current_piece and is_instance_valid(current_piece) and current_piece.type == color:
				if current_piece.special_type != GamePiece.SpecialType.NONE:
					print("Disabling special gem before color destroy: ", current_piece.special_type)
					current_piece.special_type = GamePiece.SpecialType.NONE

	# Second pass: Destroy all gems of target color (now safe from chains)
	for x in range(width):
		for y in range(height):
			var current_piece = all_pieces[x][y]
			if current_piece and is_instance_valid(current_piece) and current_piece.type == color:
				damage_piece(current_piece)
				all_pieces[x][y] = null

	# Refill Board after clearing
	await get_tree().create_timer(0.3).timeout
	await refill_board()

# ====================
# SPECIAL COMBO SYSTEM
# ====================

func _handle_special_combo(piece_1: GamePiece, piece_2: GamePiece) -> bool:
	# Returns true if a special combo was handled
	var type_1 = piece_1.special_type
	var type_2 = piece_2.special_type
	
	# Both must be special for a combo (except Rainbow which works with normal gems)
	var is_special_1 = type_1 != GamePiece.SpecialType.NONE
	var is_special_2 = type_2 != GamePiece.SpecialType.NONE
	
	# Rainbow + Normal gem handling (original behavior)
	if type_1 == GamePiece.SpecialType.RAINBOW and not is_special_2:
		await _execute_rainbow_normal_combo(piece_1, piece_2)
		return true
	elif type_2 == GamePiece.SpecialType.RAINBOW and not is_special_1:
		await _execute_rainbow_normal_combo(piece_2, piece_1)
		return true
	
	# Special + Special combos (both must be special)
	if not is_special_1 or not is_special_2:
		return false
	
	var center_pos = piece_1.grid_position
	var combo_pos = piece_1.global_position
	
	# Destroy both special gems first
	if is_instance_valid(piece_1):
		damage_piece(piece_1)
		all_pieces[piece_1.grid_position.x][piece_1.grid_position.y] = null
	if is_instance_valid(piece_2):
		damage_piece(piece_2)
		all_pieces[piece_2.grid_position.x][piece_2.grid_position.y] = null
	
	# --- RAINBOW + RAINBOW ---
	if type_1 == GamePiece.SpecialType.RAINBOW and type_2 == GamePiece.SpecialType.RAINBOW:
		await _execute_board_clear_combo(combo_pos)
		return true
	
	# --- RAINBOW + OTHER SPECIAL ---
	if type_1 == GamePiece.SpecialType.RAINBOW:
		await _execute_rainbow_special_combo(piece_2.type, type_2, combo_pos)
		return true
	elif type_2 == GamePiece.SpecialType.RAINBOW:
		await _execute_rainbow_special_combo(piece_1.type, type_1, combo_pos)
		return true
	
	# --- SAME TYPE COMBOS ---
	if type_1 == type_2:
		match type_1:
			GamePiece.SpecialType.ROW_BLAST:
				await _execute_triple_row_combo(center_pos.y, combo_pos)
			GamePiece.SpecialType.COL_BLAST:
				await _execute_triple_col_combo(center_pos.x, combo_pos)
			GamePiece.SpecialType.AREA_BOMB:
				await _execute_mega_bomb_combo(center_pos, combo_pos)
		return true
	
	# --- CROSS TYPE COMBOS ---
	# ROW + COL = Cross
	if (type_1 == GamePiece.SpecialType.ROW_BLAST and type_2 == GamePiece.SpecialType.COL_BLAST) or \
	   (type_1 == GamePiece.SpecialType.COL_BLAST and type_2 == GamePiece.SpecialType.ROW_BLAST):
		await _execute_cross_combo(center_pos, combo_pos)
		return true
	
	# ROW/COL + BOMB = 3 rows/cols
	if type_1 == GamePiece.SpecialType.ROW_BLAST and type_2 == GamePiece.SpecialType.AREA_BOMB:
		await _execute_triple_row_combo(center_pos.y, combo_pos)
		return true
	if type_2 == GamePiece.SpecialType.ROW_BLAST and type_1 == GamePiece.SpecialType.AREA_BOMB:
		await _execute_triple_row_combo(center_pos.y, combo_pos)
		return true
	if type_1 == GamePiece.SpecialType.COL_BLAST and type_2 == GamePiece.SpecialType.AREA_BOMB:
		await _execute_triple_col_combo(center_pos.x, combo_pos)
		return true
	if type_2 == GamePiece.SpecialType.COL_BLAST and type_1 == GamePiece.SpecialType.AREA_BOMB:
		await _execute_triple_col_combo(center_pos.x, combo_pos)
		return true
	
	return false

func _execute_rainbow_normal_combo(rainbow: GamePiece, other: GamePiece) -> void:
	var target_color = other.type
	print("RAINBOW SWAP! Creating blast for color: ", target_color)
	
	Audio.play_sfx("explosion")
	spawn_floating_text("RAINBOW!", 0, "purple", rainbow.global_position)
	
	if is_instance_valid(rainbow):
		damage_piece(rainbow)
		all_pieces[rainbow.grid_position.x][rainbow.grid_position.y] = null
	
	await _destroy_gems_by_color_safe(target_color)

func _execute_board_clear_combo(pos: Vector2) -> void:
	print("!!! MEGA COMBO: RAINBOW + RAINBOW = BOARD CLEAR !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("BOARD CLEAR!", 0, "purple", pos)
	
	current_combo += 1
	var total_damage = 0
	
	# Destroy everything
	for x in range(width):
		for y in range(height):
			var piece = all_pieces[x][y]
			if piece and is_instance_valid(piece):
				total_damage += 20  # Higher damage per gem for board clear
				damage_piece(piece)
				all_pieces[x][y] = null
	
	damage_dealt.emit(total_damage, "purple", width * height, current_combo)
	mana_gained.emit(width * height * 5, "purple")
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

func _execute_cross_combo(center: Vector2i, pos: Vector2) -> void:
	print("!!! CROSS COMBO: ROW + COL !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("CROSS BLAST!", 0, "yellow", pos)
	
	current_combo += 1
	var destroyed_count = 0
	var destroyed_positions: Array[Vector2i] = []
	
	# Clear row
	for x in range(width):
		if Vector2i(x, center.y) not in destroyed_positions:
			destroyed_positions.append(Vector2i(x, center.y))
	
	# Clear column
	for y in range(height):
		if Vector2i(center.x, y) not in destroyed_positions:
			destroyed_positions.append(Vector2i(center.x, y))
	
	# Destroy all marked positions
	for grid_pos in destroyed_positions:
		var piece = all_pieces[grid_pos.x][grid_pos.y]
		if piece and is_instance_valid(piece):
			# Chain reaction for other specials
			if piece.special_type != GamePiece.SpecialType.NONE:
				activate_special_gem(piece)
			damage_piece(piece)
			all_pieces[grid_pos.x][grid_pos.y] = null
			destroyed_count += 1
	
	damage_dealt.emit(destroyed_count * 10, "yellow", destroyed_count, current_combo)
	mana_gained.emit(destroyed_count * 5, "yellow")
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

func _execute_triple_row_combo(center_y: int, pos: Vector2) -> void:
	print("!!! TRIPLE ROW COMBO !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("3X ROW!", 0, "red", pos)
	
	current_combo += 1
	var destroyed_count = 0
	
	# Clear 3 rows (center-1, center, center+1)
	for dy in range(-1, 2):
		var target_y = center_y + dy
		if target_y >= 0 and target_y < height:
			for x in range(width):
				var piece = all_pieces[x][target_y]
				if piece and is_instance_valid(piece):
					if piece.special_type != GamePiece.SpecialType.NONE:
						activate_special_gem(piece)
					damage_piece(piece)
					all_pieces[x][target_y] = null
					destroyed_count += 1
	
	damage_dealt.emit(destroyed_count * 10, "red", destroyed_count, current_combo)
	mana_gained.emit(destroyed_count * 5, "red")
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

func _execute_triple_col_combo(center_x: int, pos: Vector2) -> void:
	print("!!! TRIPLE COL COMBO !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("3X COL!", 0, "blue", pos)
	
	current_combo += 1
	var destroyed_count = 0
	
	# Clear 3 columns (center-1, center, center+1)
	for dx in range(-1, 2):
		var target_x = center_x + dx
		if target_x >= 0 and target_x < width:
			for y in range(height):
				var piece = all_pieces[target_x][y]
				if piece and is_instance_valid(piece):
					if piece.special_type != GamePiece.SpecialType.NONE:
						activate_special_gem(piece)
					damage_piece(piece)
					all_pieces[target_x][y] = null
					destroyed_count += 1
	
	damage_dealt.emit(destroyed_count * 10, "blue", destroyed_count, current_combo)
	mana_gained.emit(destroyed_count * 5, "blue")
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

func _execute_mega_bomb_combo(center: Vector2i, pos: Vector2) -> void:
	print("!!! MEGA BOMB COMBO: 5x5 EXPLOSION !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("MEGA BOMB!", 0, "yellow", pos)
	
	current_combo += 1
	var destroyed_count = 0
	
	# Clear 5x5 area
	for dx in range(-2, 3):
		for dy in range(-2, 3):
			var tx = center.x + dx
			var ty = center.y + dy
			if tx >= 0 and tx < width and ty >= 0 and ty < height:
				var piece = all_pieces[tx][ty]
				if piece and is_instance_valid(piece):
					if piece.special_type != GamePiece.SpecialType.NONE:
						activate_special_gem(piece)
					damage_piece(piece)
					all_pieces[tx][ty] = null
					destroyed_count += 1
	
	damage_dealt.emit(destroyed_count * 12, "yellow", destroyed_count, current_combo)
	mana_gained.emit(destroyed_count * 5, "yellow")
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

func _execute_rainbow_special_combo(target_color: String, special_type: GamePiece.SpecialType, pos: Vector2) -> void:
	print("!!! RAINBOW + SPECIAL COMBO: Converting all ", target_color, " to ", special_type, " !!!")
	Audio.play_sfx("explosion")
	Audio.vibrate_heavy()
	spawn_floating_text("ULTRA COMBO!", 0, "purple", pos)
	
	# First pass: Convert all gems of target color to the special type
	var converted_pieces: Array[GamePiece] = []
	for x in range(width):
		for y in range(height):
			var piece = all_pieces[x][y]
			if piece and is_instance_valid(piece) and piece.type == target_color:
				piece.special_type = special_type
				_update_piece_visual(piece)
				converted_pieces.append(piece)
				
				# Small VFX for conversion
				var t = create_tween()
				t.tween_property(piece, "scale", Vector2(1.3, 1.3), 0.1)
				t.tween_property(piece, "scale", Vector2.ONE, 0.1)
	
	# Wait for conversion animation
	await get_tree().create_timer(0.3).timeout
	
	# Second pass: Activate all converted specials (chain explosion!)
	current_combo += 1
	for piece in converted_pieces:
		if is_instance_valid(piece):
			# Store position before activation
			var grid_pos = piece.grid_position
			
			# Disable to prevent infinite recursion
			piece.special_type = GamePiece.SpecialType.NONE
			
			# Execute the effect based on type
			match special_type:
				GamePiece.SpecialType.ROW_BLAST:
					_clear_row_silent(grid_pos.y)
				GamePiece.SpecialType.COL_BLAST:
					_clear_col_silent(grid_pos.x)
				GamePiece.SpecialType.AREA_BOMB:
					_clear_area_silent(grid_pos, 1)
			
			# Destroy the converted piece
			damage_piece(piece)
			all_pieces[grid_pos.x][grid_pos.y] = null
	
	await get_tree().create_timer(0.3).timeout
	await refill_board()

# Helper: Clear row without emitting signals (for combo chains)
func _clear_row_silent(y: int) -> void:
	for x in range(width):
		var piece = all_pieces[x][y]
		if piece and is_instance_valid(piece):
			damage_piece(piece)
			all_pieces[x][y] = null

# Helper: Clear column without emitting signals
func _clear_col_silent(x: int) -> void:
	for y in range(height):
		var piece = all_pieces[x][y]
		if piece and is_instance_valid(piece):
			damage_piece(piece)
			all_pieces[x][y] = null

# Helper: Clear area without emitting signals
func _clear_area_silent(center: Vector2i, radius: int) -> void:
	for dx in range(-radius, radius + 1):
		for dy in range(-radius, radius + 1):
			var tx = center.x + dx
			var ty = center.y + dy
			if tx >= 0 and tx < width and ty >= 0 and ty < height:
				var piece = all_pieces[tx][ty]
				if piece and is_instance_valid(piece):
					damage_piece(piece)
					all_pieces[tx][ty] = null
